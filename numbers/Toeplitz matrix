Toeplitz Matrix
Given a square matrix, find if it is a Toeplitz matrix or not.
A Toeplitz (or diagonal-constant) matrix is a matrix where each descending diagonal from left to right is constant (i.e., all elements in a diagonal are same).

Input: An N x N matrix
Output: Boolean
Example
Input:    [[3, 4, 5, 6],
		[2, 3, 4, 5],
		[1, 2, 3, 4],
		[0, 1, 2, 3]]
=>	Output: True
Constraints
Time Complexity: O(N^2)
Auxiliary Space Complexity: O(1)

Remember, for a matrix to be considered a toeplitz, the elements in each descending diagonal must be the same.
Solution
Iterate over the first row in the matrix
At each cell descend diagonally checking to see if each element is the same as the starting cell
If true, continue descending
If false, return False
Iterate over the first column in the matrix
At each cell descend diagonally checking to see if each element is the same as the starting cell
If true, continue descending
If false, return False
If we reach the end of both loops without returning false then the matrix must be a toeplitz and we can return True


#include <iostream>
#include <vector>
using namespace std;

//Hi!

bool toeplitzMatrix(vector<vector<int>> A){
    int row = A.size();
    int col = A[0].size();
    bool flag = true;
    for(int i = 0; i < row-1; i++){
        for(int j = 0; j < col-1; j++){
            if(A[i][j] != A[i+1][j+1])
                flag = false;
            cout << "for matrix " << A[i][j] << " " << A[i+1][j+1] << " "  << flag << endl; 
                
        }
    }    
    
    for(int i = 0; i < col-1; i++){
        for(int j = 0; j < row-1; j++){
            if(A[i][j] != A[i+1][j+1])
                flag = false;
             cout << "for matrix" << A[i][j] << " " << A[i+1][j+1] << " "  << flag << endl; 
        }
    }
    return flag;
    
}

int main() {
    vector<vector<int>> A = {{3, 4, 5, 6},
                             {2, 4, 4, 5},
                             {1, 2, 3, 4},
                             {0, 1, 2, 3}};
    
    bool result = toeplitzMatrix(A);
    cout << result << endl;
    return 0;
}

/*
Input:    
00 01 02 03
10 11 12 13
20 21 22 23
30 31 32 33

        [[3, 4, 5, 6],
        [2, 3, 4, 5],
        [1, 2, 3, 4],
        [0, 1, 2, 3]]
=>    Output: True
*/



