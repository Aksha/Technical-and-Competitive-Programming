

//Logic1 : 
//Straightforward logic: Sort the given array O(nlogn). Pick the middle element if array size is even. Pick the avg of middle elements if the size is odd.

// Logic 2 : 
// two heap 

1, 2, 3, 4  // max heap.   top is 3

  5 , 6 , 7     // min heap.  top 4 

/*
  implement max and min heap
  rebalance tree at every step
*/


clase StockMedianTracker {
  private:
    priority_queue<int> max_heap;
    priority_queue<int,vector<int>,great<int>> min_heap;

    void insert(double val) {
      
      if(max_heap.empty()) {
        max_heap.insert(val); //1
      }
       if(min_heap.empty()) {
        min_heap.insert(val); //0
      }

      if(val < max_heap.top()) {
        max_heap.insert(val);
      }

      if(val >= min_heap.top()) {
        min_heap.insert(val);
      }

      //rebalance 
      // max is always bigger than min or they match
      if(max_heap.size() < min_heap.size()+1) {
          double curr_val = min_heap.top();
          min_heap.pop();
          max_heap.insert(curr_val);
      }
    }



SOLUTION:
class MedianFinder {
public:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    MedianFinder() {
    }
    void addNum(int num) {
        maxHeap.push(num);
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.top();
        return (maxHeap.top() + minHeap.top()) / 2.0;
    }
};
  
}
  
