Objective: Print all the paths from left top cor足ner to right bot足tom cor足ner in two dimen足sional array.

Input: Two Dimensional array

Output: Print all the paths.

refer the diagram attached.

Time Complexity: O(mn)

public class PrintAllPathIn2DArray {

	int rowCount;
	int colCount;
	int[][] arrA;

	public PrintAllPathIn2DArray(int arrA[][]) {
		this.arrA = arrA;
		rowCount = arrA.length;
		colCount = arrA[0].length;
	}

	public void printAll(int currentRow, int currentColumn, String path) {
		if (currentRow == rowCount - 1) {
			for (int i = currentColumn; i < colCount; i++) {
				path += "-" + arrA[currentRow][i];
			}
			System.out.println(path);
			return;
		}
		if (currentColumn == colCount - 1) {
			for (int i = currentRow; i <= rowCount - 1; i++) {
				path += "-" + arrA[i][currentColumn];
			}
			System.out.println(path);
			return;
		}
		path = path + "-" + arrA[currentRow][currentColumn];
		printAll(currentRow + 1, currentColumn, path);
		printAll(currentRow, currentColumn + 1, path);
	//	printAll(currentRow + 1, currentColumn + 1, path);
	}

	public static void main(String args[]) {
		int[][] a = { { 1, 2, 3 }, { 4, 5, 6 } };
		PrintAllPathIn2DArray p = new PrintAllPathIn2DArray(a);
		p.printAll(0, 0, "");
	}

}

Another recursive approach using Dynamic programming with backtracking:
# input: n - a positive integer representing the grid size.
# output: number of valid paths from (0,0) to (n-1,n-1).

function numOfPathsToDest(n):
    # allocate a 2D array for memoization
    memo = [][]

    # the memoization array is initialized with -1
    # to indicate uncalculated squares.
    for i from 0 to n-1:
        for j from 0 to n-1:
            memo[i][j] = -1

    return numOfPathsToSquare(n-1, n-1, memo)


# input:
#    i, j - a pair of non-negative integer coordinates
#    memo - a 2D memoization array.
# output:
#    number of paths from (0,0) to the square represented in (i,j),

function numOfPathsToSquare(i, j, memo):
    if (i < 0 OR j < 0):
        return 0
    else if (i < j):
        memo[i][j] = 0
    else if (memo[i][j] != -1):
        return memo[i][j] 
    else if (i == 0 AND j == 0):
        memo[i][j] = 1
    else:
        memo[i][j] = numOfPathsToSquare(i, j -1, memo) +
        numOfPathsToSquare(i - 1, j, memo)

    return memo[i][j]
Time Complexity: first, notice that in order to calculate the number of paths
to a specific square, we need all the square south and west to it. This implies
that all squares beneath the diagonal are calculated. In addition, almost every 
square value is used twice - for the square north to it and east to it (except for the border squares, which are used once). 
This means that our time complexity is O(mn), since the recursive function is called once or twice for about 
half of the squares, and each call takes O(1) time.

Space Complexity: the memoization requires the space complexity to be also O(mn), since we save values for all squares.



